package de.hpi.ddm.algorithms;

import de.hpi.ddm.structures.SHA256Hash;

import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;

/**
 * Cracks a password given its SHA256 hash, by a combination algorithm of a given length. Here, a combination
 * means that each character of the password belongs to a given character set, with no further restrictions.
 */
public class CombinationCracker {
    private final byte[] choices;
    private final int times;

    public CombinationCracker(String choices, int times) {
        if (choices == null || choices.length() == 0)
            throw new IllegalArgumentException("CombinationCracker: 'choices' must be a non-null, non-empty string.");
        if (!StandardCharsets.US_ASCII.newEncoder().canEncode(choices))
            throw new IllegalArgumentException("CombinationCracker: 'choices' can only contain ASCII characters.");
        if (times <= 0)
            throw new IllegalArgumentException("CombinationCracker: 'times' must be a positive integer.");

        this.choices = choices.getBytes(StandardCharsets.US_ASCII);
        this.times = times;
    }

    /**
     * Tries to crack the given hash using the instance's combination cracker configuration.
     * @return The cracked plaintext.
     */
    public String crack(SHA256Hash targetHash) {
        if (targetHash == null)
            throw new IllegalArgumentException("CombinationCracker: 'targetHash' must not be null.");

        // Calculate the total number of combinations, which will be used for the loop end condition.
        // Note that this implementation is limited to ~2^63 combinations, but that should be plenty for our use case
        long numCombinations = BigInteger.valueOf(choices.length).pow(times).longValueExact();

        // Initialize the combination array with the first combination
        byte[] combination = new byte[times];
        Arrays.fill(combination, choices[0]);

        for (long iCombination = 0; iCombination < numCombinations; iCombination++) {
            // Check if the current combination matches the target hash
            if (SHA256Hash.fromDataHash(combination, combination.length).equals(targetHash))
                return new String(combination, StandardCharsets.US_ASCII);

            // Advance to the next combination. To do this, we can interpret 'iCombination' as a number in base
            // 'choices.length', where each digit represents the current choice index in 'combination'.
            // Here, we update the items in 'combination' corresponding to the changing digits when we increase 'iCombination'
            long r = (iCombination + 1);
            for (int i = 0, x = 0; i < times && x == 0; i++)
            {
                x = (int)(r % choices.length);
                r /= choices.length;
                combination[i] = choices[x];
            }
        }

        throw new RuntimeException("The hash is not generated by any of the attempted combinations.");
    }
}
